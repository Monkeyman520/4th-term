1. 补码的优势
   1. 加法变减法
   2. 解决了符号的问题
   3. 解决了小数点对齐的问题
   4. 能自动那个判断是否溢出
   
2. 大端法和小端法

   1. 计算机存储数据都是从低地址到高地址，而大端法和小端法的区别就是存储数据时是取数据的低位存放 在高地址还是高位存放在高地址。 
      1. 大端法：数据低位存放高地址。 
      2. 小端法：数据高位存放高地址。

3. `movx`
       其中 x 可以是下面的字符：
         1，l  用于32位的长字值
         2，w  用于16位的字值
         3，b  用于8位的字节值

     实例：

   ​    `movl  %eax,   %ebx     #把32位的EAX寄存器值传送给32为的EBX寄存器值

   ​    movw  %ax,    %bx      #把32位的EAX寄存器值传送给32为的EBX寄存器值

   ​    movb   %al,    %lx       #把32位的EAX寄存器值传送给32为的EBX寄存器值

4. 寄存器

   1. 通用寄存器:
        数据寄存器:
        AH(8位)  AL(8位)  AX(16位)   (AX和AL又称累加器)

        BH(8位)  BL(8位)  BX(16位)   (BX又称基址寄存器,唯一作为存储器指针使用寄存器)  

        CH(8位)  CL(8位)  CX(16位)   (计数器，CX用于字符串操作，控制循环的次数,CL用于移位)

        DH(8位)  DL(8位)  DX(16位)   (数据，DX一般用来做32位的乘除法时存放被除数或者保留余数)

       

        指针寄存器:
        SP 堆栈指针 (存放栈顶地址)

        BP 基址指针 (存放堆栈基址偏移)

   2.  FLAG 标志寄存器

       　① 进位标志　CF，记录运算时最高有效位产生的进位值。

      　  ② 符号标志　SF，记录运算结果的符号。结果为负时置1，否则置0。

      　  ③ 零标志　　ZF，运算结果为0时ZF位置1，否则置0。

      　  ④ 溢出标志　OF，在运算过程中，如操作数超出了机器可表示数的范围称为溢出。溢出时OF位置1，否则置0。

      　  ⑤ 辅助进位标志　AF，记录运算时第3位（半个字节）产生的进位值。

      　  ⑥ 奇偶标志　PF，用来为机器中传送信息时可能产生的代码出错情况提供检验条件。当结果操作数中1的个数为偶数时置1，否则置0。

   3. 段寄存器
        CS 代码段  IP

        DS 数据段  

        SS 堆栈段  SP BP

        ES 附加段

